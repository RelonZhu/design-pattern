# 概念
- - -
七大设计原则是设计模式的基础，同时也是指导我们日常开发的基本原则，主要包括
1. 开闭原则
2. 单一职责原则
3. 接口隔离原则
4. 依赖倒置原则
5. 里氏替换原则
6. 迪米特法则
7. 合成复用原则

## 1. 开闭原则
### 1.1 定义
>开闭原则（Open Closed Principle，OCP）由勃兰特・梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object
> Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，
> but closed for modification），这就是开闭原则的经典定义

**开闭原则的直观含义是：当需求发生改变时，在不对现有代码进行修改的情况下，能够对代码功能进行拓展**
### 1.2 使用开闭原则有什么好处

1. 降低测试难度
   
    当功能A不能满足现有需求时，若直接改动原有代码，则可能会导致改动后的代码无法兼容原有业务而出现错误，而基于拓展，则只需要测试新增的
代码功能即可
2. 提高代码灵活性及可复用性

    通常而言，粒度越小则可复用性越高越灵活，代码在方法级别，在重用方面表现会更好
3. 提高代码可维护性
    
    代码均基于拓展，且各类之间功能相对固定，若违背此原则，则在业务场景复杂的情况下，可能一个对象中包含众多的方法，维护难度将越来越高
### 1.3 实现方式
通常通过接口来抽象出一个相对稳定的功能集合，由实现类实现这些操作，当现有功能无法满足功能时，视需求派生一个新的实现类来满足新增的续期即可

### 1.4 场景及代码示例
>场景说明
> >一艘轮船，开始只能够在水里运行，现需要其能够登录，在陆地运行。定义IShip接口规定船的行为，定义Steamship实现IShip接口，实现在海里运行，
> >拓展Steamship类，实现两栖功能

参照代码：demo.principle.ocp中的例子

## 2 单一职责原则
### 2.1 定义
>单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特・C.马丁（Robert C. Martin）于《敏捷软件开发：原则、
模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该***有且仅有一个引起它变化的原因***，否则类应该被拆分（There 
should never be more than one reason for a class to change）

开闭原则强调引起变化的原因，强调一个类不应该承担过多的职责，***最好也不要包含有其他影响到其他类或对象的功能，业务逻辑代码除外***,因为如果包含的职责过多，一方面当某一个职责发生变化，很有可能会引起其他职责发
生变化，另一方面，如果需要引用类中的某一职责，那么不可避免的会将类中一系列职责全部包含进来，容易造成功能或代码冗余。

**可以通过上边的说明总结这样一句话：让正确的对象做正确的事**
### 2.2 使用单一职责原则的好处
1. 当一个类的功能相对单一时，这个类的结构就会变得比较固定，相应的，代码可读性就会提高，进而也会提高代码的可维护性
2. 功能变更变得更容易，因为功能相对单一，那么在变动时就无须过度关注其他
### 2.3 实现方式
单一职责原则定义简单，但是相对功能(职责)划分却比较困难，主要是需要合理把握功能划分的度，若划分过细，容易出现类定义过多的情况。
demo.principles.srp.antirsp下列出了一个 不太符合单一职责原则的例子。

### 2.4 最佳实践
1. 单一职责原则通常适用于**实体类**或者**工具类**的定义，不太适合VO对象、业务逻辑层定义，因为这一类对象不可避免的会发生对象或方法
   的组合
   
2. 单一职责的根本目的是为了实现高内聚低耦合
   
3. 通常在定义一个实体类时，命名就感觉找不到一个合适的名词来形容，那多半这个实体类定义是有问题的
   
4. 把握一个原则：合适的类来做合适的事，尽量少的定义上帝对象(A God Object aka an Object that knows everything and does everything.
   上帝对象，什么都知道，什么都做),因为在使用的时候会连带大量不需要的数据，你看着那些用不到的数据很烦，但是干不掉，会不会很气?

## 3. 接口隔离原则
### 3.1 定义
接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口
与单一职责原则的区别：
* 单一职责原则强调职责，属于业务逻辑上的划分，接口隔离注重的是特定客户端(模块)应有专门的接口，比如按照单一职责，一个接口包括了10个方法(职责)，
但是有五个模块在调用，那么按照接口隔离原则，最好是将这10个方法对应到这5个接口中
* 单一职责强调实现细节，接口隔离原则强调整体结构构建

### 3.2 使用接口隔离原则的好处
1. 避免了大而杂的接口定义，在接口定义和使用时都能保证很好的灵活性

2. 一定场景下，可以通过接口继承等方式逐层递进，从而使接口定义更具层次

3. 减少代码冗余，试想一下我们定义一个庞大的接口，什么事情都要做，那么在实现接口时势必需要处理那些用不到的方法，即使实现成为一个空方法，
依然也会造成代码冗余
   
4. 提高接口内聚性，防止一些不应被调用的方法在错误的位置被调用

### 3.3 实现方式
1. 接口应在合理程度内保证尽量小，不会特别臃肿(注意：根据接口隔离原则拆分接口时，首先必须满足单一职责原则)

2. 接口尽量高内聚，即是提高接口、类、模块的处理能力，减少对外的交互

3. 服务定制，有些接口可能会被多方使用，但是使用的情况是不完全一致的，比如同样是查询服务，内部用户调用时可能执行比较正常，公网用户查询就会
出现并发问题，这种情况下就不适合两个平台公用一个方法
   
4. 接口设计是有限度的，粒度过细将会大大增加维护难度，太过庞大又容易产生冗余代码，此原则**可意会不可言传?**

### 3.4 最佳实践
摘抄了几个指导性的方法以供参考
1. 一个接口只服务于一个子模块或业务逻辑
   
2. 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨 肉”，而不是“肥嘟嘟”的一大堆方法 
   
3. 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化 处理
   
4. 了解环境，拒绝盲从，根据具体情况具体分析。每个项目或产品都有特定的环境因素，别看到大师是这样做的 你就照抄。千万别，环境不同，接口拆分的标准就不同。

一个简单的例子见：demo.principles.isp

## 4. 依赖倒置原则
### 4.1 定义
依赖倒置原则（Dependence Inversion Principle，DIP）是高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该
依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions 
should not depend upon details. Details should depend upon abstractions）。**抽象就是指接口或抽象类**
其核心思想是：要面向接口编程，不要面向实现编程。
在JAVA中我们可以这样理解：
1. 模块间的依赖应是通过抽象实现的，实现类之间不应发生直接的依赖关系，依赖关系应该通过接口或抽象类实现

2. 接口或抽象类不应依赖于实现类

3. 实现类应依赖于接口或抽象类
### 4.2 使用依赖倒置原则有什么好处
1. 可以通过接口或抽象类进行约束，避免多人并行开发的风险，比如出现相同功能的方法

2. 代码可维护性更好，更易拓展

3. 有效提升开发效率，考虑这样的一个情况，A和B两人在同一项目下进行开发，两人共同开发看电视的功能，分工如下：A同学负责开发看电视的个体，
也就是人，B同学开发电视功能，那么想看电视的前提是电视能够播放节目，这样A同学就高度依赖B同学的开发内容，借用依赖倒置原则，B同学定义好一
   接口，接口中包含了电视播放play()的功能，并提供给A，A只需要通过接口进行方法调用，完全不用关注play()方法是怎么实现的
   
### 4.3 实现方式
依赖倒置的核心观点是：**抽象依赖**，有以下三种方式建立依赖：
1. 构造函数传递依赖对象

2. 方法参数传递依赖对象

3. set方法传递依赖对象
### 4.4 最佳实践
1. 每个类最好都有一个接口或抽象类
2. 变量的表面类型最好是接口或抽象类
3. 视具体情况看是否需要从具体类上派生，一般实体类或者是进行维护性开发工作可以有这样的继承关系，但应注意继承链最好不要过长
4. 尽量不要重写基类已经实现的方法，尤其是当基类为抽象类时

## 5.里氏替换原则
### 5.1 定义
里氏替换原则（Liskov Substitution Principle，LSP）是指：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure 
that any property proved about supertype objects also holds for subtype objects）。
里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的
基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范


