## 1. 工厂方法模式定义
先复习一下简单工厂模式的缺点，简单工厂一个显著的缺点是如果需要增加一个新的具体产品，那么就需要修改原有产品创建方法，是违反开闭原则(只对拓展
开放，对修改关闭)，所以工厂方法模式应运而生，其解决了简单工厂模式遇到的问题，当需要创建一类产品时，每增加一个具体的产品，就新增一个新的工厂
与之对应，满足了开闭原则

### 2. 优缺点
* 优点
    1. 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
    2. 灵活性增强，对于新产品的创建，无须改动原有产品创建过程。
    3. 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则([设计原则]())。
* 缺点
    1. 每增加一个产品就需要增加一个产品类和创建该产品的工厂，类的个数容易过多，增加复杂度
    2. 增加了系统的抽象性和理解难度
    3. 抽象产品只能生产一种产品，此弊端可使用[抽象工厂模式]()解决。
## 3. 应用场景
适用于创建同一品类的产品，产品共同点较多的情况，如汽车，基本属性是一致的
## 4. 实现
代码实现参照：
工厂方法一般需要如下几个角色：
1. 抽象工厂：负责规范具体工厂的行为
2. 具体工厂: 负责具体产品的创建工作
3. 抽象产品：负责规范需要创建的产品品类行为，定义共有方法
4. 具体产品：需要创建的具体产品

#### 定义抽象产品
```java
/**
 * 定义抽象产品汽车
 */
public interface Car {
    void run();
}
```
#### 定义具体产品
```java
public class Benz implements Car {
    @Override
    public void run() {
        System.out.println("奔驰在马路上飞驰。。。");
    }
}
```
```java
public class Audi implements Car {
    @Override
    public void run() {
        System.out.println("奥迪在路上飞驰。。。");
    }
}
```
#### 定义抽象工厂
```java
public interface CarFactory {
    Car produce();
}
```
#### 定义具体工厂
```java
public class BenzFactory implements CarFactory{
    @Override
    public Car produce() {
        System.out.println("奔驰工厂生产奔驰。。。");
        return new Benz();
    }
}
```
```java
public class AudiFactory implements CarFactory{
    @Override
    public Car produce() {
        System.out.println("奥迪工厂生产奥迪。。。");
        return new Audi();
    }
}
```
#### 测试类
```java
public class FactoryMethodTest {
    public static void main(String[] args) {
        // 调用奔驰工厂生产奔驰
        CarFactory benzFactory = new BenzFactory();
        Car benz = benzFactory.produce();
        benz.run();
        // 调用奥迪工厂生产奥迪
        CarFactory audiFactory = new AudiFactory();
        Car audi = audiFactory.produce();
        audi.run();
    }
}
```
测试结果：
>奔驰工厂生产奔驰。。。
> 
>奔驰在马路上飞驰。。。
>
>奥迪工厂生产奥迪。。。
> 
>奥迪在路上飞驰。。。

## 5. 拓展
可以将产品与生产该产品的具体工厂配置通过外部配置文件或其他方式独立在代码外，详细参考：