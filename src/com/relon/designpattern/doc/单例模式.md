## 1. 单例模式定义
1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3. 单例类对外提供一个访问该单例的全局访问点。
## 2. 优缺点
* 优点
    1. 单例模式可以保证内存里只有一个实例，减少了内存的开销。
    2. 可以避免对资源的多重占用。
    3. 单例模式设置全局访问点，可以优化和共享资源的访问。

* 缺点：
    1. 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。
    2. 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。
    3. 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。
  
## 3. 应用场景
1. 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。
2. 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
3. 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。
4. 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
5. 频繁访问数据库或文件的对象。
6. 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。
7. 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。
## 4. 常用的单例模式实现
### 4.1 饿汉模式――静态常量
```java
public class HungrySingletonA {
    // 1.私有化构造器，防止外部创建
    private HungrySingletonA() {}
    // 2. 创建私有对象
    private static final HungrySingletonA instance = new HungrySingletonA();
    // 3. 提供公共获取对象方法
    public static HungrySingletonA getInstance() {
        return instance;
    }
}
```
### 4.2 饿汉模式――静态代码块
```java
public class HungrySingletonB {
    // 1.私有化构造器，防止外部创建
    private HungrySingletonB() {}
    // 2. 创建私有对象
    private static HungrySingletonB instance;
    // 3. 静态代码块初始化
    static {
        instance = new HungrySingletonB();
    }
    // 4. 提供公共获取对象方法
    public static HungrySingletonB getInstance() {
        return instance;
    }
}
```
### 4.3 懒汉模式――非线程安全
```java
public class LazySingletonA {
    // 1.私有构造函数
    private LazySingletonA() {}
    // 2.声明单例对象
    private static LazySingletonA instance;
    // 3.获取实例
    public static LazySingletonA getInstance() {
        if (instance == null) {
            instance = new LazySingletonA();
        }
        return instance;
    }
}
```
### 4.4 懒汉模式――线程安全
```java
public class LazySingletonB {
// 1.私有构造函数
private LazySingletonB() {}
// 2.声明单例对象
private static LazySingletonB instance;
// 3.获取实例
public synchronized static LazySingletonB getInstance() {
if (instance == null) {
instance = new LazySingletonB();
}
return instance;
}
}
```
### 4.5 双重检锁模式
```java
public class DoubleCheckSingleton {
    // 1.私有构造函数
    private DoubleCheckSingleton() {}
    // 2.声明单例对象――volatile作用保证可见性
    private static volatile DoubleCheckSingleton instance;
    // 3.获取实例
    public static DoubleCheckSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckSingleton.class) {
                if (instance == null) {
                    instance = new DoubleCheckSingleton();
                }
            }
        }
        return instance;
    }
}
```
### 4.6 静态内部类
```java
public class StaticInnerClassSingleton {
    // 1.私有化构造函数
    private StaticInnerClassSingleton() {}
    // 2.定义静态内部类
    private static class InnerSingleton {
        private static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();
    }
    // 3.提供获取实例方法
    public static StaticInnerClassSingleton getInstance() {
        return InnerSingleton.INSTANCE;
    }
}
```
### 4.7 基于枚举模式
```java
public enum SingletonEnum {
    INSTANCE;
    public void say() {
        System.out.println("实例的say方法被调用");
    }
}
```
## 5 对比
|   类型   | 特点                                                       | 推荐指数                 |
| :----------: | ---------------------------------------------------------- | -------------------- |
|饿汉――静态常量|1.非懒加载2.线程安全|☆|
|饿汉――静态代码块|同上|☆|
|懒汉――非线程安全|1.懒加载2.非线程安全,仅适用于单线程场景|☆|
|懒汉――线程安全|1.懒加载2.线程安全3.效率较低|☆☆|
|双重检锁|1.效率高2.线程安全**3.防止不了反射攻击(参照代码ReflectionTest)**|☆☆☆☆|
|静态内部类|同上|☆☆☆☆|
|枚举|1.线程安全2.实现简单3.能够防止反射/序列化/反序列化无效的情况|☆☆☆☆☆|