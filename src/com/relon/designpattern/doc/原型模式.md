## 1. 原型模式定义
原型模式的定义：通过已经创建好的对象作为原型，通过复制方式来创建其他对象，其中作为原型的实例上记录了要创建对象类型。通过原型模式可以提高
对象创建的效率。
>Q:为什么原型模式可以提高对象创建效率？
>A:原型模式本质是对象克隆，那么就要提到常用的对象创建方式：类加载->分配对象内存->属性初始化->调用<init>方法进行初始化，通过对象复制(原
> 型模式)可以简化这一创建流程

## 2. 优缺点
* 优点：
  1. Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
  2. 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如
     恢复到历史某一状态），可辅助实现撤销操作。
* 缺点：
  1. 需要为每一个类都配置一个 clone 方法
  2. clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
  3. 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，
     实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。
## 3. 应用场景
1. 类初始化需要加载的资源很多，如果采用原型模式可以显著提升效率，那么应该使用
2. 只需要修改对象的少数属性，而不改变其他属性
## 4. 实现
```java
/**
 * 定义孙悟空实体类，并实现Cloneable接口，实现clone()方法，赋予孙悟空可以分身的本领
 */
public class WuKong implements Cloneable{
    private String name;
    private String address;
    
    // 省略getter、setter方法
    
    @Override
    protected WuKong clone() {
        WuKong newWuKong = null;
        try {
            newWuKong = (WuKong) super.clone();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return newWuKong;
    }
}
```
Main方法中进行试验
```java
public class Main {
    public static void main(String[] args) {
        WuKong wuKong = new WuKong();
        wuKong.setName("孙悟空");
        wuKong.setAddress("花果山水帘洞");
        System.out.println("孙悟空真身：" + wuKong);
        WuKong newWuKong = wuKong.clone();
        System.out.println("孙悟空化身：" + newWuKong);
        System.out.println("真身与化身是否是同一个？" + (wuKong == newWuKong));
        System.out.println("真身是否相同？" + (wuKong.getClass() == newWuKong.getClass()));
    }
}
```
得到如下结果
>孙悟空原身：WuKong{name='孙悟空', address='花果山水帘洞'}
>孙悟空化身：WuKong{name='孙悟空', address='花果山水帘洞'}
>真身与化身是否是同一个？false
>真身是否相同？true

**结论：**
>1. 任何对象执行clone()方法得到的新对象都不相同，即o.clone() != o
>2. 克隆对象和原对象的类信息是一样的，即o.getClass() == o.clone().getClass() 

# 5. 拓展――深拷贝
* 浅拷贝：对于基本类型的属性，会复制其值，对于引用类型的属性，会复制引用，那么将会导致两个不同对象的属性引用同一个地址，若其中一个修改，将会
影响到另一对象的该属性
* 深拷贝：基本类型不变，引用类型也会创建一个新的属性

代码示例
详细代码参照：
#### 定义八戒
```java
public class BaJie implements Cloneable, Serializable {
    private String name;
    private String address;
    private Tang master;

    // 省略getter、setter、toString

    @Override
    protected BaJie clone() {
        BaJie baJie = null;
        try {
            baJie = (BaJie) super.clone();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return baJie;
    }

    public BaJie deepCloneMaster() {
        BaJie baJie = null;
        try {
            baJie = (BaJie) super.clone();
            baJie.master = baJie.master.clone();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return baJie;
    }

    /**
     * 基于序列化方式的深拷贝
     * @return
     */
    public BaJie deepCloneSerial() {
        BaJie baJie = null;
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(this);

            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bis);
            baJie = (BaJie) ois.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return baJie;
    }

}
```
#### 定义唐僧
```java
public class Tang implements Cloneable, Serializable {
    private String name;
    private String address;

    // 省略getter、setter、toString
    
    @Override
    protected Tang clone() {
        Tang tang = null;
        try {
            tang = (Tang) super.clone();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return tang;
    }
}
```
#### 测试类
```java
public class DeepCloneTest {
    public static void main(String[] args) {
        // 数据初始化
        BaJie baJie = new BaJie();
        Tang master = new Tang();
        baJie.setName("猪八戒");
        baJie.setAddress("高老庄");
        master.setName("唐僧");
        master.setAddress("东土大唐");
        baJie.setMaster(master);
        // 浅拷贝引用类型属性
        BaJie newBaJie = baJie.clone();
        System.out.println("八戒真身：" + baJie);
        System.out.println("八戒分身：" + newBaJie);
        System.out.println("八戒分身和化身是否为一个师傅？" + (baJie.getMaster() == newBaJie.getMaster()));
        // 仅深拷贝(二级影分身)师傅属性――》师傅也跟着换了
        BaJie baJie1 = baJie.deepCloneMaster();
        System.out.println("二级影分身：" + baJie1);
        System.out.println("二级影分身之后是否还是同一个师傅？" + (baJie.getMaster() == baJie1.getMaster()));
        // 高阶二级影分身(很好的应对对象中有多个引用类型属性的情况)
        BaJie baJie2 = baJie.deepCloneSerial();
        System.out.println("高阶二级影分身：" + baJie2);
        System.out.println("高阶二级影分身之后是否还是同一个师傅？" + (baJie.getMaster() == baJie1.getMaster()));
    }
}
```
#### 测试结果
>八戒真身：BaJie{name='猪八戒', address='高老庄', master=Tang{name='唐僧', address='东土大唐'}}
>八戒分身：BaJie{name='猪八戒', address='高老庄', master=Tang{name='唐僧', address='东土大唐'}}
>八戒分身和化身是否为一个师傅？true
>二级影分身：BaJie{name='猪八戒', address='高老庄', master=Tang{name='唐僧', address='东土大唐'}}
>二级影分身之后是否还是同一个师傅？false
>高阶二级影分身：BaJie{name='猪八戒', address='高老庄', master=Tang{name='唐僧', address='东土大唐'}}
>高阶二级影分身之后是否还是同一个师傅？false


