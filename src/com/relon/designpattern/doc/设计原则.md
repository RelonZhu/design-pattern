# 概念
- - -
七大设计原则是设计模式的基础，同时也是指导我们日常开发的基本原则，主要包括
1. 开闭原则
2. 单一职责原则
3. 接口隔离原则
4. 依赖倒置原则
5. 里氏替换原则
6. 迪米特法则
7. 合成复用原则

## 1. 开闭原则
### 1.1 定义
>开闭原则（Open Closed Principle，OCP）由勃兰特・梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object
> Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，
> but closed for modification），这就是开闭原则的经典定义

**开闭原则的直观含义是：当需求发生改变时，在不对现有代码进行修改的情况下，能够对代码功能进行拓展**
### 1.2 使用开闭原则有什么好处

1. 降低测试难度
   
    当功能A不能满足现有需求时，若直接改动原有代码，则可能会导致改动后的代码无法兼容原有业务而出现错误，而基于拓展，则只需要测试新增的
代码功能即可
2. 提高代码灵活性及可复用性

    通常而言，粒度越小则可复用性越高越灵活，代码在方法级别，在重用方面表现会更好
3. 提高代码可维护性
   
    代码均基于拓展，且各类之间功能相对固定，若违背此原则，则在业务场景复杂的情况下，可能一个对象中包含众多的方法，维护难度将越来越高
### 1.3 实现方式
通常通过接口来抽象出一个相对稳定的功能集合，由实现类实现这些操作，当现有功能无法满足功能时，视需求派生一个新的实现类来满足新增的续期即可

### 1.4 场景及代码示例
>场景说明
> >一艘轮船，开始只能够在水里运行，现需要其能够登录，在陆地运行。定义IShip接口规定船的行为，定义Steamship实现IShip接口，实现在海里运行，
> >拓展Steamship类，实现两栖功能

参照代码：demo.principle.ocp中的例子

## 2 单一职责原则
### 2.1 定义
>单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特・C.马丁（Robert C. Martin）于《敏捷软件开发：原则、
模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该***有且仅有一个引起它变化的原因***，否则类应该被拆分（There 
should never be more than one reason for a class to change）

开闭原则强调引起变化的原因，强调一个类不应该承担过多的职责，***最好也不要包含有其他影响到其他类或对象的功能，业务逻辑代码除外***,因为如果包含的职责过多，一方面当某一个职责发生变化，很有可能会引起其他职责发
生变化，另一方面，如果需要引用类中的某一职责，那么不可避免的会将类中一系列职责全部包含进来，容易造成功能或代码冗余。

**可以通过上边的说明总结这样一句话：让正确的对象做正确的事**
### 2.2 使用单一职责原则的好处
1. 当一个类的功能相对单一时，这个类的结构就会变得比较固定，相应的，代码可读性就会提高，进而也会提高代码的可维护性
2. 功能变更变得更容易，因为功能相对单一，那么在变动时就无须过度关注其他
### 2.3 实现方式
单一职责原则定义简单，但是相对功能(职责)划分却比较困难，主要是需要合理把握功能划分的度，若划分过细，容易出现类定义过多的情况。
demo.principles.srp.antirsp下列出了一个 不太符合单一职责原则的例子。

### 2.4 最佳实践
1. 单一职责原则通常适用于**实体类**或者**工具类**的定义，不太适合VO对象、业务逻辑层定义，因为这一类对象不可避免的会发生对象或方法
   的组合
   
2. 单一职责的根本目的是为了实现高内聚低耦合
   
3. 通常在定义一个实体类时，命名就感觉找不到一个合适的名词来形容，那多半这个实体类定义是有问题的
   
4. 把握一个原则：合适的类来做合适的事，尽量少的定义上帝对象(A God Object aka an Object that knows everything and does everything.
   上帝对象，什么都知道，什么都做),因为在使用的时候会连带大量不需要的数据，你看着那些用不到的数据很烦，但是干不掉，会不会很气?

## 3. 接口隔离原则
### 3.1 定义
接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口
与单一职责原则的区别：
* 单一职责原则强调职责，属于业务逻辑上的划分，接口隔离注重的是特定客户端(模块)应有专门的接口，比如按照单一职责，一个接口包括了10个方法(职责)，
但是有五个模块在调用，那么按照接口隔离原则，最好是将这10个方法对应到这5个接口中
* 单一职责强调实现细节，接口隔离原则强调整体结构构建

### 3.2 使用接口隔离原则的好处
1. 避免了大而杂的接口定义，在接口定义和使用时都能保证很好的灵活性

2. 一定场景下，可以通过接口继承等方式逐层递进，从而使接口定义更具层次

3. 减少代码冗余，试想一下我们定义一个庞大的接口，什么事情都要做，那么在实现接口时势必需要处理那些用不到的方法，即使实现成为一个空方法，
依然也会造成代码冗余
   
4. 提高接口内聚性，防止一些不应被调用的方法在错误的位置被调用

### 3.3 实现方式
1. 接口应在合理程度内保证尽量小，不会特别臃肿(注意：根据接口隔离原则拆分接口时，首先必须满足单一职责原则)

2. 接口尽量高内聚，即是提高接口、类、模块的处理能力，减少对外的交互

3. 服务定制，有些接口可能会被多方使用，但是使用的情况是不完全一致的，比如同样是查询服务，内部用户调用时可能执行比较正常，公网用户查询就会
出现并发问题，这种情况下就不适合两个平台公用一个方法
   
4. 接口设计是有限度的，粒度过细将会大大增加维护难度，太过庞大又容易产生冗余代码，此原则**可意会不可言传?**

### 3.4 最佳实践
摘抄了几个指导性的方法以供参考
1. 一个接口只服务于一个子模块或业务逻辑
   
2. 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨 肉”，而不是“肥嘟嘟”的一大堆方法 
   
3. 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化 处理
   
4. 了解环境，拒绝盲从，根据具体情况具体分析。每个项目或产品都有特定的环境因素，别看到大师是这样做的 你就照抄。千万别，环境不同，接口拆分的标准就不同。

一个简单的例子见：demo.principles.isp

## 4. 依赖倒置原则
### 4.1 定义
依赖倒置原则（Dependence Inversion Principle，DIP）是高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该
依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions 
should not depend upon details. Details should depend upon abstractions）。**抽象就是指接口或抽象类**
其核心思想是：要面向接口编程，不要面向实现编程。
在JAVA中我们可以这样理解：
1. 模块间的依赖应是通过抽象实现的，实现类之间不应发生直接的依赖关系，依赖关系应该通过接口或抽象类实现

2. 接口或抽象类不应依赖于实现类

3. 实现类应依赖于接口或抽象类
### 4.2 使用依赖倒置原则有什么好处
1. 可以通过接口或抽象类进行约束，避免多人并行开发的风险，比如出现相同功能的方法

2. 代码可维护性更好，更易拓展

3. 有效提升开发效率，考虑这样的一个情况，A和B两人在同一项目下进行开发，两人共同开发看电视的功能，分工如下：A同学负责开发看电视的个体，
也就是人，B同学开发电视功能，那么想看电视的前提是电视能够播放节目，这样A同学就高度依赖B同学的开发内容，借用依赖倒置原则，B同学定义好一
   接口，接口中包含了电视播放play()的功能，并提供给A，A只需要通过接口进行方法调用，完全不用关注play()方法是怎么实现的
   
### 4.3 实现方式
依赖倒置的核心观点是：**抽象依赖**，有以下三种方式建立依赖：
1. 构造函数传递依赖对象

2. 方法参数传递依赖对象

3. set方法传递依赖对象
### 4.4 最佳实践
1. 每个类最好都有一个接口或抽象类
2. 变量的表面类型最好是接口或抽象类
3. 视具体情况看是否需要从具体类上派生，一般实体类或者是进行维护性开发工作可以有这样的继承关系，但应注意继承链最好不要过长
4. 尽量不要重写基类已经实现的方法，尤其是当基类为抽象类时

## 5.里氏替换原则
### 5.1 定义
里氏替换原则（Liskov Substitution Principle，LSP）是指：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure 
that any property proved about supertype objects also holds for subtype objects）。
里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的
基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范

**另一种解释是：可以使用父类的位置都能够使用子类代替，而不影响其原有功能**
### 5.2 使用里氏替换原则有什么好处
1. 里氏替换原则是实现开闭原则的重要方式之一。
2. 克服了继承中重写父类造成的可复用性变差的缺点。
3. 保证了动作的准确性。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。
### 5.3 实现方式
参见：demo.principle.lsp
1. 完全实现抽象类中的抽象方法，但是非抽象方法要慎重，以防影响到原有功能。
   
   注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发 生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系
   代替继承
2. 子类中可以定义自己特有的方法
3. 覆盖或实现父类的方法时输入参数可以被放大
4. 覆写或实现父类的方法时输出结果可以被缩小
### 5.4 最佳实践
在使用LSP时，尽量避免为子类增加“个性”，一是如果把子类当做父类使用，那么子类的“个性”将被埋没，另外若将子类单独使用，那么类之间的关系又会
变得相对混乱，所以最好的方式就是遵循抽象定义规范，实现类定义实现逻辑即可
## 6. 迪米特法则
### 6.1 定义
迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，只与你的直接朋友交谈，不跟“陌生人”说话（
Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互
调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

>"朋友"定义：朋友类的定义是 这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内 部的类不属于朋友类

### 6.2 使用迪米特原则的作用
1. 降低类之间的耦合性
2. 提高了类的可复用性
3. 但迪米特法则要求无须直接调用则没必要直接通信，那么就可能产生比较多的中间类，需要在实现时予以考量
### 6.3 实现方式
示例代码demo.principles.lod

从迪米特法则的定义和特点可知，它强调以下两点：
从依赖者的角度来说，只依赖应该依赖的对象。
从被依赖者的角度说，只暴露应该暴露的方法。

所以，在运用迪米特法则时要注意以下 6 点。
在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
在类的结构设计上，尽量降低类成员的访问权限。
在类的设计上，优先考虑将一个类设置成不变类。
在对其他类的引用上，将引用其他对象的次数降到最低。
不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
谨慎使用序列化（Serializable）功能

### 6.4 最佳实践
一个类包含的public方法越多，那么在涉及修改时，需要关注的方向越多，对应的风险也就越高，所以在涉及时应该多考虑一点，是否还可以再减少
public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前 不加访问权限，则默认为包类型）、protected
等访问权限，是否可以加上final关键字等
## 7. 合成复用原则
###  7.1 定义
>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在
>软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范
### 7.2 使用合成复用原则的作用
通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。
1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。
1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

## 总结

|   设计原则   | 归纳                                                       | 目的                 |
| :----------: | ---------------------------------------------------------- | -------------------- |
|   开闭原则   | 对拓展开放，对修改关闭                                     | 降低维护风险         |
| 单一职责原则 | 一个类的职责应该尽可能单一，避免“上帝”对象                 | 方法清晰，可读性好   |
| 接口隔离原则 | 接口中职责应尽可能划分合理，尽量保证一个调用方对应一个接口 | 功能解耦             |
| 依赖倒置原则 | 类直接应该通过抽象建立关联，面向接口编程                   | 代码约束性好，易拓展 |
| 里氏替换原则 | 父类存在的地方可以使用子类代替而不影响原有功能             | 防止继承泛滥         |
|  迪米特原则  | 如果两个类之间无须之间建立关联，那就不要之间进行通信       | 代码清晰，减少臃肿   |
| 合成复用原则 | 优先使用组合、聚合等关联关系进行软件复用，然后才考虑继承   | 降低代码耦合         |

