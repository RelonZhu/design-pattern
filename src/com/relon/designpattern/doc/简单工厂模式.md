## 1. 简单工厂模式
通常我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。

>简单工厂模式通常通过静态方法创建对象，因此，简单工厂模式也被称为静态工厂方法模式

## 2. 优缺点
* 优点
  1. 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。
  2. 客户端无需知道所创建具体产品的类名，只需知道参数即可。
  3. 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类
* 缺点
  1. 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。
  2. 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度
  3. 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂
  4. 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。
## 3. 应用场景
比较适用于创建品类较少产品的情况，相比而言实现比较简单，实现比较方便
## 4. 实现
下述源码参见：
工厂模式通常包含如下几个角色:
1. 简单工厂：用于生成产品，可以在创建逻辑中添加其他业务逻辑
2. 抽象产品：需要创建的所有产品的父类，规范具体产品的共有方法
3. 具体产品：实际需要创建的产品

#### 定义抽象产品类
```java
/**
 * 定义抽象产品汽车
 */
public interface Car {
    void run();
}
```
#### 定义两个具体的产品类
```java
public class Benz implements Car{
    @Override
    public void run() {
        System.out.println("奔驰在马路上飞驰。。。");
    }
}
```
```java
public class Audi implements Car{
    @Override
    public void run() {
        System.out.println("奥迪在路上飞驰。。。");
    }
}
```
#### 定义工厂类
```java
public class CarFactory {
    public static Car produceCar(CarTypeEnum carTypeEnum) {
        switch (carTypeEnum) {
            case AUDI:return new Audi();
            case BENZ:return new Benz();
            default:return null;
        }
    }
}
```
#### 工厂测试类
```java
public class SimpleFactoryTest {
    public static void main(String[] args) {
        // 生产奔驰
        Car benz = CarFactory.produceCar(CarTypeEnum.BENZ);
        benz.run();
        // 生产奥迪
        Car audi = CarFactory.produceCar(CarTypeEnum.AUDI);
        audi.run();
    }
}
```
测试结果：
>奔驰在马路上飞驰。。。
> 
>奥迪在路上飞驰。。。

**通过上边例子可以看到简单工厂的一个缺点就是如果要增加一个产品，那么就需要修改CarFactory.produceCar()方法，所以引入了工厂方法模式**