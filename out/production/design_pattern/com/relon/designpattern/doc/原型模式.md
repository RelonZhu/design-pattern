## 原型模式定义
原型模式的定义：通过已经创建好的对象作为原型，通过复制方式来创建其他对象，其中作为原型的实例上记录了要创建对象类型。通过原型模式可以提高
对象创建的效率。
>Q:为什么原型模式可以提高对象创建效率？
>A:原型模式本质是对象克隆，那么就要提到常用的对象创建方式：类加载->分配对象内存->属性初始化->调用<init>方法进行初始化，通过对象复制(原
> 型模式)可以简化这一创建流程

## 2. 优缺点
* 优点：
  1. Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
  2. 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如
     恢复到历史某一状态），可辅助实现撤销操作。
* 缺点：
  1. 需要为每一个类都配置一个 clone 方法
  2. clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
  3. 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，
     实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。
## 3. 应用场景
1. 类初始化需要加载的资源很多，如果采用原型模式可以显著提升效率，那么应该使用
2. 只需要修改对象的少数属性，而不改变其他属性
## 4. 实现
```java
/**
 * 定义孙悟空实体类，并实现Cloneable接口，实现clone()方法，赋予孙悟空可以分身的本领
 */
public class WuKong implements Cloneable{
    private String name;
    private String address;
    
    // 省略getter、setter方法
    
    @Override
    protected WuKong clone() {
        WuKong newWuKong = null;
        try {
            newWuKong = (WuKong) super.clone();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return newWuKong;
    }
}
```
Main方法中进行试验
```java
public class Main {
    public static void main(String[] args) {
        WuKong wuKong = new WuKong();
        wuKong.setName("孙悟空");
        wuKong.setAddress("花果山水帘洞");
        System.out.println("孙悟空真身：" + wuKong);
        WuKong newWuKong = wuKong.clone();
        System.out.println("孙悟空化身：" + newWuKong);
        System.out.println("真身与化身是否是同一个？" + (wuKong == newWuKong));
        System.out.println("真身是否相同？" + (wuKong.getClass() == newWuKong.getClass()));
    }
}
```
得到如下结果
>孙悟空原身：WuKong{name='孙悟空', address='花果山水帘洞'}
>孙悟空化身：WuKong{name='孙悟空', address='花果山水帘洞'}
>真身与化身是否是同一个？false
>真身是否相同？true

**结论：**
>1. 任何对象执行clone()方法得到的新对象都不相同，即o.clone() != o
>2. 克隆对象和原对象的类信息是一样的，即o.getClass() == o.clone().getClass() 

# 5. 拓展――深拷贝
* 浅拷贝：对于基本类型的属性，会复制其值，对于引用类型的属性，会复制引用，那么将会导致两个不同对象的属性引用同一个地址，若其中一个修改，将会
影响到另一对象的该属性
* 深拷贝：基本类型不变，引用类型也会创建一个新的属性



